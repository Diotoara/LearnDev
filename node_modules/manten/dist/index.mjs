var te=Object.defineProperty;var i=(e,t)=>te(e,"name",{value:t,configurable:!0});import{setMaxListeners as se}from"node:events";import{inspect as ne}from"node:util";import M from"node:os";import{expect as Me}from"expect";let b=!0;const w=typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{};let T=0;if(w.process&&w.process.env&&w.process.stdout){const{FORCE_COLOR:e,NODE_DISABLE_COLORS:t,NO_COLOR:n,TERM:o,COLORTERM:s}=w.process.env;t||n||e==="0"?b=!1:e==="1"||e==="2"||e==="3"?b=!0:o==="dumb"?b=!1:"CI"in w.process.env&&["TRAVIS","CIRCLECI","APPVEYOR","GITLAB_CI","GITHUB_ACTIONS","BUILDKITE","DRONE"].some(r=>r in w.process.env)?b=!0:b=process.stdout.isTTY,b&&(process.platform==="win32"||s&&(s==="truecolor"||s==="24bit")?T=3:o&&(o.endsWith("-256color")||o.endsWith("256"))?T=2:T=1)}let P={enabled:b,supportLevel:T};function $(e,t,n=1){const o=`\x1B[${e}m`,s=`\x1B[${t}m`,r=new RegExp(`\\x1b\\[${t}m`,"g");return l=>P.enabled&&P.supportLevel>=n?o+(""+l).replace(r,o)+s:""+l}i($,"kolorist");const y=$(2,22),D=$(31,39),B=$(32,39),H=$(33,39),_=i(e=>Number.isFinite(e)?e:0,"toZeroIfInfinity");function oe(e){return{days:Math.trunc(e/864e5),hours:Math.trunc(e/36e5%24),minutes:Math.trunc(e/6e4%60),seconds:Math.trunc(e/1e3%60),milliseconds:Math.trunc(e%1e3),microseconds:Math.trunc(_(e*1e3)%1e3),nanoseconds:Math.trunc(_(e*1e6)%1e3)}}i(oe,"parseNumber");function re(e){return{days:e/86400000n,hours:e/3600000n%24n,minutes:e/60000n%60n,seconds:e/1000n%60n,milliseconds:e%1000n,microseconds:0n,nanoseconds:0n}}i(re,"parseBigint");function ie(e){switch(typeof e){case"number":{if(Number.isFinite(e))return oe(e);break}case"bigint":return re(e)}throw new TypeError("Expected a finite number or bigint")}i(ie,"parseMilliseconds");const ce=i(e=>e===0||e===0n,"isZero"),ae=i((e,t)=>t===1||t===1n?e:`${e}s`,"pluralize"),le=1e-7,ue=24n*60n*60n*1000n;function k(e,t){const n=typeof e=="bigint";if(!n&&!Number.isFinite(e))throw new TypeError("Expected a finite number or bigint");t={...t};const o=e<0?"-":"";e=e<0?-e:e,t.colonNotation&&(t.compact=!1,t.formatSubMilliseconds=!1,t.separateMilliseconds=!1,t.verbose=!1),t.compact&&(t.unitCount=1,t.secondsDecimalDigits=0,t.millisecondsDecimalDigits=0);let s=[];const r=i((f,m)=>{const h=Math.floor(f*10**m+le);return(Math.round(h)/10**m).toFixed(m)},"floorDecimals"),l=i((f,m,h,d)=>{if(!((s.length===0||!t.colonNotation)&&ce(f)&&!(t.colonNotation&&h==="m"))){if(d??=String(f),t.colonNotation){const p=d.includes(".")?d.split(".")[0].length:d.length,S=s.length>0?2:1;d="0".repeat(Math.max(0,S-p))+d}else d+=t.verbose?" "+ae(m,f):h;s.push(d)}},"add"),c=ie(e),a=BigInt(c.days);if(t.hideYearAndDays?l(BigInt(a)*24n+BigInt(c.hours),"hour","h"):(t.hideYear?l(a,"day","d"):(l(a/365n,"year","y"),l(a%365n,"day","d")),l(Number(c.hours),"hour","h")),l(Number(c.minutes),"minute","m"),!t.hideSeconds)if(t.separateMilliseconds||t.formatSubMilliseconds||!t.colonNotation&&e<1e3&&!t.subSecondsAsDecimals){const f=Number(c.seconds),m=Number(c.milliseconds),h=Number(c.microseconds),d=Number(c.nanoseconds);if(l(f,"second","s"),t.formatSubMilliseconds)l(m,"millisecond","ms"),l(h,"microsecond","\xB5s"),l(d,"nanosecond","ns");else{const p=m+h/1e3+d/1e6,S=typeof t.millisecondsDecimalDigits=="number"?t.millisecondsDecimalDigits:0,ee=p>=1?Math.round(p):Math.ceil(p),A=S?p.toFixed(S):ee;l(Number.parseFloat(A),"millisecond","ms",A)}}else{const f=(n?Number(e%ue):e)/1e3%60,m=typeof t.secondsDecimalDigits=="number"?t.secondsDecimalDigits:1,h=r(f,m),d=t.keepDecimalsOnWholeSeconds?h:h.replace(/\.0+$/,"");l(Number.parseFloat(d),"second","s",d)}if(s.length===0)return o+"0"+(t.verbose?" milliseconds":"ms");const u=t.colonNotation?":":" ";return typeof t.unitCount=="number"&&(s=s.slice(0,Math.max(t.unitCount,1))),o+s.join(u)}i(k,"prettyMilliseconds");const g=`
`,fe="    ",{log:E,error:L}=console,de=B("\u2714"),me=D("\u2716"),he=H("\u2022"),ge=y("\u25CB"),I=i(()=>{const e=new Date,t=String(e.getHours()).padStart(2,"0"),n=String(e.getMinutes()).padStart(2,"0"),o=String(e.getSeconds()).padStart(2,"0");return y(`${t}:${n}:${o}`)},"formatTimestamp"),O=i(({startTime:e,timeout:t,endTime:n})=>{const o=(n||Date.now())-e;let s=k(o);return t&&(s+=` / ${k(t)}`),o<50?"":` ${y(`(${s})`)}`},"prettyDuration"),be=i(e=>e.replaceAll(/^/gm,fe),"indentMultiline"),N=i((e,t=!0)=>{const{title:n,attempt:o,retry:s}=e;let r=`${n+O(e)}`;return t&&s>1&&(r+=y(` (${o}/${s})`)),r},"getTestTitle"),v=i((e,t,n)=>{let o=`${I()} ${me} ${N(e)}`;n&&(o+=` [${n}]`),L(o),L(`${be(ne(t))}
`)},"logTestFail"),ye=i(e=>{E(`${I()} ${de} ${N(e)}`)},"logTestSuccess"),j=i(e=>{E(`${I()} ${ge} ${N(e,!1)}`)},"logTestSkip"),pe=i(e=>{if(e.length===0)return;const t=[];let n=0,o=0,s=0,r,l;for(const a of e)a.startTime&&(!r||r>a.startTime)&&(r=a.startTime),a.endTime===void 0?t.push(a):((!l||l<a.endTime)&&(l=a.endTime),a.error?o+=1:a.skip?s+=1:n+=1);let c="";if(t.length>0){for(const a of t)c+=`${g}${he} ${a.title+O(a)}`;c+=g}c+=`${g}${y(k((l??Date.now())-r))}`,c+=g+(n>0?B:y)(`${n.toLocaleString()} passed`),o>0&&(c+=g+D(`${o.toLocaleString()} failed`)),s>0&&(c+=g+y(`${s.toLocaleString()} skipped`)),t.length>0&&(c+=g+H(`${t.length.toLocaleString()} pending`)),c+=g,E(c)},"logReport"),we=i(()=>{let e,t;const n=new Promise((o,s)=>{e=o,t=s});return Object.assign(n,{resolve:e,reject:t})},"createDeferred"),Te=i((e,t)=>{const n=we(),o=setTimeout(()=>{const s=new Error(`Timeout: ${e}ms`);t?.abort(s),n.reject(s)},e);return Object.assign(n,{timeoutId:o})},"setTimer"),q=i((e,t,n)=>{if(!e||!("then"in e)||t===void 0||t===0)return e;const o=Te(t,n);return Promise.race([e,o]).finally(()=>{clearTimeout(o.timeoutId)})},"timeLimitFunction"),V=i(e=>{const t=[];return{addHook:i(s=>{t.push(s)},"addHook"),runHooks:i(async(...s)=>{for(const r of t)try{await r(...s)}catch(l){await e(l)}},"runHooks")}},"createHook"),Se=i(async(e,t)=>{for(let n=1;n<=t;n+=1)try{await e(n);return}catch(o){if(n===t)throw o}},"retry");class Y extends Error{static{i(this,"SkipError")}constructor(t){super(t||"Test skipped"),this.name="SkipError"}}const W=i(e=>(e&&typeof e=="object"&&"matcherResult"in e&&e.constructor.name==="JestAssertionError"&&delete e.matcherResult,e),"patchJestAssertionError"),x=i(async(e,t)=>{const{testFunction:n,timeout:o}=e,s=V(c=>{v(e,c,"onTestFail")}),r=i(async c=>{await s.runHooks(c)},"handleError"),l=V(async c=>{v(e,W(c),"onTestFinish")});try{await Se(async c=>{e.attempt=c,e.startTime=Date.now();const a=new AbortController;let u;t&&(u=i(()=>{a.signal.aborted||a.abort(t.abortController.signal.reason)},"handleParentAbort"),t.abortController.signal.addEventListener("abort",u),t.abortController.signal.aborted&&u());try{await q(n({signal:a.signal,onTestFail:s.addHook,onTestFinish:l.addHook,skip:i(f=>{throw new Y(f)},"skip")}),o,a),ye(e)}catch(f){if(f instanceof Y)e.skip=!0,j(e);else throw v(e,W(f)),await r(f),f}finally{t&&u&&t.abortController.signal.removeEventListener("abort",u),a.signal.aborted||a.abort(),await l.runHooks(),e.endTime=Date.now()}},e.retry)}catch(c){e.error=c,process.exitCode=1}},"runTest"),G=[];process.on("exit",()=>{pe(G)});const U=process.env.TESTONLY,J=i((e,t)=>((n,o,s)=>{if(e&&(n=`${e} ${n}`),t&&(t.testsStarted=!0),U&&!n.includes(U))return Promise.resolve();const r={title:n,testFunction:o,retry:1};if(s!==void 0&&(typeof s=="number"?r.timeout=s:(r.timeout=s?.timeout,s?.retry&&(r.retry=s?.retry))),G.push(r),t?.skipped){r.skip=!0,r.skipReason=t.skipReason;const l=Date.now();return r.startTime=l,r.endTime=l,j(r),Promise.resolve()}return(async()=>{const c=i(async()=>{if(t?.concurrencyLimiter){const a=await t.concurrencyLimiter.acquire();try{await x(r,t)}finally{a()}}else await x(r,t)},"executeTest")();t&&t.pendingTests.push(c),await c})()}),"createTest"),$e=i(async e=>{for(;e.length>0;){const t=e.splice(0);await Promise.all(t)}},"waitAllPromises"),Le=i(e=>("default"in e&&(e=e.default),"default"in e&&(e=e.default),e),"unwrapModule"),R=i(e=>{let t=typeof e=="number"?e:Z(),n=0;const o=[];let s;return e==="auto"&&(s=setInterval(()=>{const a=Z();if(a!==t)for(t=a;o.length>0&&n<t;){const u=o.shift();u&&(n+=1,u())}},5e3),s.unref()),{acquire:i(()=>n<t?(n+=1,Promise.resolve(()=>{n-=1;const a=o.shift();a&&(n+=1,a())})):new Promise(a=>{o.push(()=>{a(()=>{n-=1;const u=o.shift();u&&(n+=1,u())})})}),"acquire"),setLimit:i(a=>{for(t=a;o.length>0&&n<t;){const u=o.shift();u&&(n+=1,u())}},"setLimit"),cleanup:i(()=>{s&&clearInterval(s)},"cleanup")}},"createSemaphore"),Z=i(()=>{const e=M.cpus().length,t=M.loadavg()[0];return Math.max(1,Math.min(Math.floor(e*(1-Math.min(t/e,.8))),e))},"calculateAutoLimit"),z=i((e,t)=>((n,o,s)=>(e&&(n=`${e} ${n}`),t&&(t.testsStarted=!0),(async()=>{const r=F(n,s?.parallel,s?.timeout);await i(async()=>{if(t?.concurrencyLimiter){const c=await t.concurrencyLimiter.acquire();try{await r.run(o,t)}finally{c()}}else await r.run(o,t)},"executeDescribe")()})())),"createDescribe"),K=i((e,t)=>((n,...o)=>{t&&(t.testsStarted=!0);const s=i(()=>{const r=F(e);return r.run(async()=>Le(await n).apply(r,o),t)},"executeTestSuite");return t?.concurrencyLimiter?t.concurrencyLimiter.acquire().then(r=>s().finally(r)):s()}),"createRunTestSuite"),Q=J(),X=z(),C=K(),F=i((e,t,n)=>{let o;t!==void 0&&(t===!0?o=void 0:t===!1?o=R(1):typeof t=="number"?o=R(t):t==="auto"&&(o=R("auto")));const s=new AbortController;se(0,s.signal);const r={pendingTests:[],callbacks:{onFinish:[]},concurrencyLimiter:o,abortController:s,timeout:n,skipped:!1,skipReason:void 0,testsStarted:!1,run:i(async(l,c)=>{c?.skipped&&(r.skipped=!0,r.skipReason=c.skipReason);let a;c&&(a=i(()=>{s.signal.aborted||s.abort(c.abortController.signal.reason)},"handleParentAbort"),c.abortController.signal.addEventListener("abort",a),c.abortController.signal.aborted&&a());try{const u=(async()=>{await l(r.api),await $e(r.pendingTests)})();c&&c.pendingTests.push(u),await q(u,n,s)}catch(u){L(u),process.exitCode=1}finally{c&&a&&c.abortController.signal.removeEventListener("abort",a),s.signal.aborted||s.abort(),o&&o.cleanup();for(const u of r.callbacks.onFinish)try{await u()}catch(f){L(f),process.exitCode=1}}},"run")};return r.api={signal:s.signal,test:e?J(`${e} \u203A`,r):Q,describe:e?z(`${e} \u203A`,r):X,runTestSuite:e?K(e,r):C,onFinish:i(l=>{r.callbacks.onFinish.push(l)},"onFinish"),skip:i(l=>{if(r.testsStarted)throw new Error("skip() must be called before any tests or nested describes run. Move skip() to the beginning of the describe callback.");r.skipped=!0,r.skipReason=l},"skip")},r},"createContext"),De=F(),ke=i((e,t,n)=>{const o=typeof e=="string"?e:void 0,s=typeof e=="string"?t:e,r=typeof e=="string"?n:void 0;return i(async function(...c){const a=this||De;o?await a.api.describe(o,u=>s(u,...c),r):await s(a.api,...c)},"testSuiteWrapper")},"testSuite"),Ee=i(e=>{setTimeout(()=>{process.exitCode=1,console.error(D(`\u2716 Process timed out after ${e}ms`)),setImmediate(()=>process.exit(1))},e).unref()},"setProcessTimeout");export{X as describe,Me as expect,C as runTestSuite,Ee as setProcessTimeout,Q as test,ke as testSuite};
